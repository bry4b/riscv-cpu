// TODO: place preg back into free pool queue

module rename # (
    parameter NUM_REG = 32
) (
    input clk,
    input rst,

    input [4:0] rd_A,
    input [4:0] rs1_A,
    input [4:0] rs2_A,
    input [4:0] rd_B,
    input [4:0] rs1_B,
    input [4:0] rs2_B,

    output logic [4:0] prd_A_old,
    output logic [4:0] prd_A_new,
    output logic [4:0] prs1_A,
    output logic [4:0] prs2_A,
    output logic [4:0] prd_B_old,
    output logic [4:0] prd_B_new,
    output logic [4:0] prs1_B,
    output logic [4:0] prs2_B
);

`include "constants.sv";

localparam NUM_ENTRIES = 2*NUM_REG;

function automatic logic [5:0] init_RAT(int index);
    return index; 
endfunction

function automatic logic [5:0] init_free(int index);
    return NUM_REG + index;
endfunction

logic [5:0] register_alias_table [0:NUM_REG-1] = '{foreach (register_alias_table[i]) init_RAT(i)};  // index corresponds to a-reg, 6-bit value corresponds to p-reg
logic [5:0] free_pool [0:NUM_REG-1] = '{foreach (free_pool[i]) init_free(i)};                       // functions as a queue to refill 
logic [5:0] next_free_preg = free_pool[0];

always_ff @(posedge clk) begin
    if (rst) begin
        register_alias_table <= '{foreach (register_alias_table[i]) init_RAT(i)};
        free_pool <= '{foreach (free_pool[i]) init_free(i)};  
        
    end else begin
        if (rd_A != 'd0 && rd_B != 'd0) begin
            // both rd_A and rd_B need to pull from free pool
            prd_A_new <= free_pool[0];
            prd_A_old <= register_alias_table[rd_A];
            register_alias_table[rd_A] <= free_pool[0];

            prd_B_new <= free_pool[1];
            prd_B_old <= register_alias_table[rd_B];
            register_alias_table[rd_B] <= free_pool[1];
            
            free_pool <= '{free_pool[2:NUM_REG-1], 'd0, 'd0};
            
        end else if (rd_A != 'd0) begin
            // only rd_A needs to pull from free pool
            prd_A_new <= free_pool[0];
            prd_A_old <= register_alias_table[rd_A];
            register_alias_table[rd_A] <= free_pool[0];

            prd_B_new <= 5'd0; // do nothing
            prd_B_old <= 5'd0; // do nothing

            free_pool <= '{free_pool[1:NUM_REG-1], 'd0};

        end else if (rd_B != 'd0) begin
            // only rd_B needs to pull from free pool
            prd_B_new <= free_pool[0];
            prd_B_old <= register_alias_table[rd_B];
            register_alias_table[rd_B] <= free_pool[0];

            prd_A_new <= 5'd0; // do nothing
            prd_A_old <= 5'd0; // do nothing

            free_pool <= '{free_pool[1:NUM_REG-1], 'd0};
            
        end else begin
            // neither instruction pulls from free pool                             
            prd_A_new <= 5'd0; // do nothing
            prd_A_old <= 5'd0; // do nothing
            prd_B_new <= 5'd0; // do nothing
            prd_B_old <= 5'd0; // do nothing
            
        end
        
        // rename rs1, rs2
        prs1_A <= register_alias_table[rs1_A];
        prs2_A <= register_alias_table[rs2_A];

        prs1_B <= register_alias_table[rs1_B];
        prs2_B <= register_alias_table[rs2_B];

        register_alias_table[0] <= 5'd0;
    end
end

endmodule
